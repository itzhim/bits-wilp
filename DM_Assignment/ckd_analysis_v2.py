# -*- coding: utf-8 -*-
"""dm_assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xwDv3X-1JSHwtuk51ae68hfY7N8GxdkA
"""

import numpy as np 
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from matplotlib import pyplot as plt
from sklearn import tree
import seaborn as sns

def pre_process_data(data):

    # Create Pandas Dataframe
    df = pd.DataFrame(data)

    # Replace tabs and ? with NaN 
    df.replace('\t?', np.nan, inplace=True)
    df.replace('?', np.nan, inplace=True)

    # Assign values of 0 and 1 to binary attributes
    df['rbc'].replace({'normal': 0, 'abnormal': 1}, inplace=True)
    df['pc'].replace({'normal': 0, 'abnormal': 1}, inplace=True)
    df['pcc'].replace({'notpresent': 0, 'present': 1}, inplace=True)
    df['ba'].replace({'notpresent': 0, 'present': 1}, inplace=True)
    df['htn'].replace({'no': 0, 'yes': 1}, inplace=True)
    df['dm'].replace({'no': 0, '\tno':0, '\tyes':1, ' yes':1, 'yes': 1}, inplace=True)
    df['cad'].replace({'\tno':0, 'no': 0, 'yes': 1}, inplace=True)
    df['appet'].replace({'poor': 0, 'good': 1}, inplace=True)
    df['pe'].replace({'no': 0, 'yes': 1}, inplace=True)
    df['ane'].replace({'no': 0, 'yes': 1}, inplace=True)
    df['diagnosis'].replace({'notckd': 0, 'ckd': 1}, inplace=True)

    # Get the columns as list of features
    features = list(df.columns)

    # Convert features to float values
    for feature in features:
        df[feature] = df[feature].astype(float)

    # Separate the features which are inherently integer and float types
    int_list = ['bp', 'al', 'pc', 'bu', 'pcv', 'wbcc', 'dm', 'appet', 'pe', 'pcc', 'ba', 'bgr', 'age', 'su', 'rbc', 'sod', 'cad', 'ane', 'diagnosis']
    float_list = ['sc', 'hemo', 'rbcc', 'htn', 'sg', 'pot']

    # Fill missing values in dataset with the mean values
    for val in int_list:
        df[val].fillna(int(df[val].mean()), inplace=True)

    for val in float_list:
        df[val].fillna((df[val].mean()), inplace=True)

    # Get correlation between data columns (part of data pre-processing)
    cor = df.corr()
    sns.heatmap(cor, annot=True, cmap=plt.cm.Reds)
    #plt.show()
    #print(cor)

    cor_target = abs(cor["diagnosis"])
    relevant_features = cor_target[cor_target>0.5]

    # Put the most relevant features into a list
    extracted_features = list(relevant_features.index)

    # Drop features which have very low correlation with output variable
    dropped_features = [feature for feature in features]
    for feature in extracted_features:
        if feature in features:
            dropped_features.remove(feature)

    # Drop irrelevant attributes from dataset (part of data cleaning)
    df.drop(dropped_features, axis=1, inplace=True)

    # Save the pre-processed data to a CSV file
    df.to_csv('trimmed_data.csv')

    return df

# Train the classifier model
def train_classifier(df):

    # y is the output class and x is the dataset excluding the class
    y = df.diagnosis.values
    x = df.drop(['diagnosis'], axis = 1)

    # Split the dataset for training an testing
    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.33)

    # Train the classifier
    dt = DecisionTreeClassifier(random_state = 0)
    dt.fit(x_train,y_train)
    print("score :",dt.score(x_test,y_test))

    return dt

# Plot the decision tree
def plot_decision_tree(dt):
    # This is the extracted features list
    features = ['specific gravity', 'albumin', 'hemoglobin', 'packed cell volume', \
                'red blood cell count', 'hypertension', 'diabetes']
    classes = ['notckd', 'ckd']

    # Print the tree to console in text form 
    tree_text = tree.export_text(dt, feature_names = features)
    print(tree_text)

    # Plot the tree and save it
    fig = plt.figure(figsize=(25,20))
    my_tree = tree.plot_tree(dt, feature_names = features, class_names = classes, filled = True)
    fig.savefig("decision_tree.png")

if __name__ == "__main__":
    data = pd.read_csv('kidneyChronic.csv')
    pre_processed_df = pre_process_data(data)
    decision_tree = train_classifier(pre_processed_df)
    plot_decision_tree(decision_tree)
