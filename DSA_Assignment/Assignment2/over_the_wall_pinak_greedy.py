"""DSAD_Assn2_scratchspace.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H2ceNXk9UYL8yHN2dWoLG8m0ZcL0d-tz

#DSAD Assignment 2
###Problem Statement present at : https://bits-pilani.instructure.com/courses/915/assignments/4644

####First Impression
It seems to be a Knapsack sort of problem. Similar to finding the minimum number of coins of different denomination to make up a given value. [Reference | https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/]

However, instead of above method, we can also use Greedy algorithm to solve this as given here: https://www.geeksforgeeks.org/greedy-algorithm-to-find-minimum-number-of-coins/

In above case, GFG has used normal array and sorted it but we may as well use max-heap.
Also, we need to calculate minimum number of boxes for 2 towers. (or in GFG context, we need to find minimum no of coins for 2 values, not just .
one as shown in the example)
Why the above point is necessary? Its because, we need to construct both towers simultaneously, without discrimination.
For example consider a scenario where we have following blocks:
{6,5,1,1,1,1,1,1,1,1,1}
Consider that the wall height is 7.
If we first construct the first tower, our greedy algorithm will say that we can directly use blocks of height 6 and 5 to create a (6 + 5 ) = 11 height wall. Them for the second tower, we will have have to use 7x 1-height blocks.
Thus we will end up using (2 + 7) = 9 blocks.

Instead, if we construct them simultaneously, i.e. 6 will go for tower 1
5 will go for tower 2
Then,
next block, i.e. 1 will go for tower 1, thus matching the wall size
next block, i.e. 1 will go for tower 2.
next block will again go to tower 2, thus matching the wall size.
Thus, we have used (2 + 3) = 5 blocks for constructing the towers
"""

import sys
class Block:
    def __init__(self, height):
        self.ht = height

class MaxHeap:
    def __init__(self, maxsize):
        self.maxsize = maxsize
        self.size = 0   #1 because the first entry is already put to 1(ignore)
        self.Heap = []  #Initialize empty array instead#[Block(0,0)] * (self.maxsize + 1)
        self.Heap.append(Block(1*sys.maxsize))
        self.FRONT = 1

	# Function to return the position of
	# parent for the node currently
	# at pos
    def parent(self, pos):
        return pos // 2

	# Function to return the position of
	# the left child for the node currently
	# at pos
    def leftChild(self, pos):
        return 2 * pos

	# Function to return the position of
	# the right child for the node currently
	# at pos
    def rightChild(self, pos):
        return (2 * pos) + 1

	# Function that returns true if the passed
	# node is a leaf node
    def isLeaf(self, pos):
        if pos >= (self.size//2) and pos <= self.size:
            return True
        return False

	# Function to swap two nodes of the heap
    def swap(self, fpos, spos):
        self.Heap[fpos], self.Heap[spos] = (self.Heap[spos],self.Heap[fpos])
  
    # Function to heapify the node at pos (motivation from DSA slides)
    def maxHeapify(self, pos):
        largest = pos
        if (self.leftChild(pos) <= self.size and self.Heap[self.leftChild(pos)].ht > self.Heap[pos].ht):
            largest = self.leftChild(pos)
        if (self.rightChild(pos) <= self.size and self.Heap[self.rightChild(pos)].ht > self.Heap[largest].ht):
            largest = self.rightChild(pos)
        if largest != pos:
            self.Heap[pos], self.Heap[largest] = self.Heap[largest], self.Heap[pos]
            self.maxHeapify(largest)
            
    def build_max_heap(self):
        for i in reversed(range(1, (self.size//2) + 1)):
            self.maxHeapify(i)

	# Function to insert a node into the heap
    def insert(self, element):
        self.size += 1
        self.Heap.insert(self.size, Block(element))        #This insert is list insert method. Do not confuse it for the def'ed insert
        current = self.size

        #Upheap bubbling
        while (self.Heap[current].ht > self.Heap[self.parent(current)].ht):
            self.swap(current, self.parent(current))
            current = self.parent(current)
        
        if self.size > self.maxsize:
            self.maxsize = self.size

	# Function to print the contents of the heap
    def Print(self):
        print("<Position> : (ht)")
        for i in range(1, (self.size // 2) + 1):
            if (i<=self.size):
                print(" PARENT : (" + str(self.Heap[i].ht), end=")\t")
            if (2*i <= self.size):
                print(" LEFT CHILD : (" + str(self.Heap[2 * i].ht), end=")\t")
            if ((2*i + 1) <= self.size):
                print(" RIGHT CHILD : (" + str(self.Heap[2 * i + 1].ht) + ")")
        print()

	# Function to remove and return the maximum
	# element from the heap
    def extractMax(self):
        if (self.size <= 0):
            sys.exit("Heap extractMax called but there are no more elements in heap.\nExitting...")
        popped = self.Heap[self.FRONT]
        self.Heap[self.FRONT] = self.Heap[self.size]
        self.size -= 1
		#self.minHeapify(self.FRONT)
        self.build_max_heap()
		#print(popped)
        return popped

def read_input(input_file):
    try:
        with open(input_file,"r+") as file:
            lines = file.readlines()
        return lines
    except:
        sys.exit("Could not read input file. Please check")

unlimited_boxes = 0
def append_box(block, Rem_ht):
    """
    Check whether the given block can be used 
    Returns a list which contains the block height(s) if that block can be used
    This also check if the Rem_ht is greater than zero
    If it is less than zero, the function indicates its callee that the condition has been met
    Rem_ht <= 0 indicates that the tower has been constructed to satisfy its purpose.
    The indication is mostly from the Rem_ht passing :-)
    """
    global unlimited_boxes
    sub_blck_lst=[]

    if (unlimited_boxes != 0):
        while (block<Rem_ht):
            sub_blck_lst.append(block)
            Rem_ht -= block
    else:
        sub_blck_lst.append(block)
        Rem_ht -= block
    return sub_blck_lst, Rem_ht

def calculate_Greedy(heap, K, f):
    """
    Creates two lists corresponding to the two towers, each containing the blocks 
    (identified by the block height) that were used to build that particular tower
    """
    tower1_components = []
    tower2_components = []

    # initially, remaining height of tower is K
    tower1_rem_ht = K
    tower2_rem_ht = K

    while ((heap.size > 0) and ((tower1_rem_ht > 0) or ((tower2_rem_ht > 0)))):
        # simultaneous update
        # update for tower 1

        if (tower1_rem_ht > 0):
            block = heap.extractMax()

            # if the remaining height of the second tower is same as
            # the height of the current block then we we can simply
            # use the current block for it (by swapping). This will 
            # save us from using 2 boxes instead of 1. Note that 
            # this condition is not required for tower 1 as this 
            # functionality is indirectly incorporated for tower 1
            #print(tower1_rem_ht, tower2_rem_ht, block.ht)
            if (abs(tower2_rem_ht - block.ht) < 
                abs(tower1_rem_ht - block.ht)):
                temp = tower1_rem_ht
                tower1_rem_ht = tower2_rem_ht
                tower2_rem_ht = temp
                ret_list, tower1_rem_ht = append_box(block.ht, tower1_rem_ht)
                tower1_components.extend(ret_list)
            else:
                ret_list, tower1_rem_ht = append_box(block.ht, tower1_rem_ht)
                tower1_components.extend(ret_list)
        
        # check if we still have blocks left
        if (heap.size <= 0):
            break
        
        # update for tower 2
        if (tower2_rem_ht > 0):
            block = heap.extractMax()
            ret_list, tower2_rem_ht = append_box(block.ht, tower2_rem_ht)
            tower2_components.extend(ret_list)

    # at the end of the while loop, we will understand whether or not we have accomplished
    # our goal of building two towers.
    len1 = 0
    len2 = 0
    # write to the output file

    if ((tower1_rem_ht > 0) or (tower2_rem_ht > 0)):
        #print("Unable to build both towers.\nRemaining height for tower1:\t" + str(tower1_rem_ht) +
              #"\nRemaining height for tower2:\t" + str(tower2_rem_ht))
        f.write("-1\n")
    else:
        len1 = len(tower1_components)
        len2 = len(tower2_components)
        #print(len1+len2)
        f.write(str(len1 + len2) + "\n")


if __name__ == "__main__":

    inputlines = read_input("inputPS11.txt")
    num_testcases = int(inputlines[0])
    data_lines = inputlines[1:]
    f = open("outputPS11.txt", "w+")

    for i in range(0,len(data_lines),2):
        #print("---------------TestCase_" + str(i//2) + "---------------")
        N = int(data_lines[i].split()[0])
        K = int(data_lines[i].split()[-1])
        block_list = [int(x) for x in data_lines[i + 1].split()]

        if(len(block_list) != N):
            print("Something's wrong, I can feel it.")

        heap = MaxHeap(N)
        for block in block_list:
            heap.insert(block)
        #heap.Print()

        calculate_Greedy(heap, K, f)
    f.close()
